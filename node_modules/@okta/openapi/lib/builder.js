const _ = require('lodash');
const path = require('path');
const fs = require('fs');
const semver = require('semver');
const version = require('../package.json').version;
const util = require('./util');

const builder = module.exports;

builder.build = ({spec, specErrata, endpoints, models, whitelist, blacklist, pathRewriteMap, tags, modelTags, docDir, modelRenameMap}) => {
  spec = spec || {};
  spec.info = spec.info || {};
  spec.info.version = semver.inc(version, 'minor');
  spec.paths = spec.paths || {};
  spec.definitions = spec.definitions || {};
  modelRenameMap = modelRenameMap || {};

  // Track all names to see which ones actually had a collision
  // This allows us to see which classes we should add to our modelRenameMap
  const collisionDetection = {};

  // Build map of models we have: Map<className, Model>
  const getModelTags = util.buildTagMatcher(modelTags);
  const modelMap = models.reduce((map, model) => {
    const className = util.getClassName(model['$class']);

    model.easyTags = getModelTags(className);

    // Ensure that we don't have any model name collisions
    if (modelRenameMap[className]) {
      model.easyName = modelRenameMap[className];
    } else {
      model.easyName = util.cleanClassName(className);
    }
    if (!collisionDetection[model.easyName]) {
      collisionDetection[model.easyName] = [];
    }
    collisionDetection[model.easyName].push(className);

    map[className] = model;
    return map;
  }, {});

  // Track all models used in our endpoints
  const usedModels = new Set();
  builder.addEndpoints({spec, endpoints, whitelist, blacklist, pathRewriteMap, tags, usedModels, modelMap});

  // Add usedModels, with docs, to our spec
  builder.addModels({spec, modelMap, modelsToAdd: usedModels, collisionDetection});
  builder.addDocs(spec, docDir);

  // OperationIds can collide, like getUsers on /api/v1/users and /api/v1/groups/:id/users
  util.ensureUniqueOperationIds(spec);

  // Ensure all _links and _embedded are the same
  util.overrideLinksAndEmbedded(spec);

  // Ensure that all properties of models that can't be sent to Okta are readOnly
  util.ensureReadOnlyProperties(spec);

  // Add things that are missing from the spec
  _.merge(spec, specErrata);

  // Recursively remove null and undefined properties
  spec = util.removeNils(spec);

  // Ensure that we generate a consistent spec for diffing
  util.ensureConsistentStructure(spec);

  return spec;
};

// Add endpoints to the spec (known as paths in openapi)
builder.addEndpoints = ({spec, usedModels, endpoints, whitelist, blacklist, pathRewriteMap, tags, modelMap}) => {
  const isWhitelisted = util.buildListMatcher(whitelist);
  const isBlacklisted = util.buildListMatcher(blacklist);
  const pathRewriter = util.buildPathRewriter(pathRewriteMap);
  const getTags = util.buildTagMatcher(tags);
  
  endpoints.forEach((endpoint) => {
    let path = {};

    // Remove the square brackets
    let url = endpoint.url.slice(1, -1);

    // Standardize the id field (only affects /api/v1/users/{id:/+} for now)
    url = url.replace('{id:.+}', '{id}');

    const [rewrittenPath] = pathRewriter(url);
    if (!isWhitelisted(rewrittenPath) || isBlacklisted(rewrittenPath)) {
      return;
    }

    if (!endpoint.httpAccessors || !endpoint.httpAccessors[0]) {
      console.log(`No httpAccessors: ${url}`);
      return;
    }
    if (endpoint.httpAccessors.length > 1) {
      console.log(`Multiple httpAccessors: ${url}`);
    }
    const method = endpoint.httpAccessors[0].toLowerCase();

    path.operationId = endpoint.javaFunction.replace(/^read/, 'get');
    path.tags = getTags(url);
    path.consumes = ['application/json'];
    path.produces = ['application/json'];
    path.parameters = [];
    path.security = [{
      'api_token': []
    }];

    // Convert the returnType into a model schema
    const schema = util.getModelSchema(endpoint.returnType, usedModels, modelMap);

    const successResponse = {
      description: 'Success'
    };

    if (schema) {
      successResponse.schema = schema;

      if (schema.type && schema.type === 'array') {
        path.operationId = path.operationId.replace(/^get/, 'list');
      }
    }

    path.responses = {
      200: successResponse
    };

    // FIXME: there's currently an error in the endpoints json that causes a strange type offset
    // See /api/v1/users/{userId}/factors/{userFactorId}/devices/{deviceId} in endpoints.json for an example
    const parameters = [];
    endpoint.parameters.forEach((parameter, parameterIndex) => {
      const nextParameter = endpoint.parameters[parameterIndex + 1];
      if (nextParameter && parameter.value === nextParameter.value) {
        return;
      }
      parameters.push(parameter);
    });

    const paramTypes = endpoint.paramTypes.filter((paramType) => {
      return paramType !== 'interface javax.servlet.http.HttpServletResponse';
    });

    if (parameters.length !== paramTypes.length) {
      console.log(`Can't determine types for: ${method} ${endpoint.url}`);
      return;
    }

    parameters.forEach((parameter, parameterIndex) => {
      const param = {};
      param.name = parameter.value || 'body';
      const parameterType = paramTypes[parameterIndex];
      param.type = util.toOpenAPIType(parameterType);

      if (param.type === 'object') {
        param.schema = util.getModelSchema(parameterType, usedModels, modelMap);
        // Object parameters don't have a type
        delete param.type;
      }

      // define format
      if (param.type === 'integer') {
        param.format = 'int32';
      }

      // define defaults
      if (parameter.defaultValue || parameter.defaultValue === '') {
        if (param.type === 'string') {
          param.default = parameter.defaultValue;
        } else {
          param.default = JSON.parse(parameter.defaultValue);
        }
      }

      // determine if required
      if (parameter.required) {
        param.required = true;
      }
      
      // determine what type of parameter it is
      if (parameter.pathParam) {
        param.in = 'path';
        param.required = true;

        // a path param can't be an object, so remove any schema
        delete param.schema;
      } else if (param.name === 'body') {
        param.in = 'body';
        if (!param.schema) {
          console.log(`no body schema for: ${method} ${url}`)
          return;
        } else if (param.schema['$ref']) {
          param.name = _.camelCase(_.last(param.schema['$ref'].split('/')));
        }
        param.required = true;
      } else {
        param.in = 'query';
      }

      path.parameters.push(param);
    });

    [url, path] = pathRewriter(url, path);

    spec.paths[url] = spec.paths[url] || {};
    spec.paths[url][method] = path;
  });
};

// Add a single model to the spec
builder.addModel = ({spec, model, newModels, modelMap, collisionDetection}) => {
  const definition = {
    type: 'object',
    properties: {}
  };

  if (model.easyTags && model.easyTags.length) {
    definition['x-okta-tags'] = model.easyTags;
  }

  for (let propertyName in model.properties) {
    let property = model.properties[propertyName];

    if (!property) {
      continue;
    }

    let newProp = {};
    switch(property.type) {
      case 'string':
        newProp.type = 'string';
        if (property.enum) {
          newProp.enum = property.enum;
        }
        break;
        
      case 'array':
        newProp.type = 'array';
        const refType = property.items['$ref'];
        if (refType && (property.items.type === 'object' || property.items.type === 'array')) {
          newProp.items = util.getModelSchema(refType, newModels, modelMap);
        } else {
          newProp.items = {type: property.items.type};
        }
        break;

      case 'boolean':
        newProp.type = 'boolean';
        break;

      case 'number':
      case 'integer':
        newProp.type = 'integer';
        break;

      case 'object':
        if (property['$ref']) {
          newProp = util.getModelSchema(property['$ref'], newModels, modelMap);
        } else {
          newProp.type = 'object';
        }
    }

    definition.properties[propertyName] = newProp;
  }

  // Ensure that every model has only one representation
  if (spec.definitions[model.easyName]) {
    if (collisionDetection[model.easyName] && collisionDetection[model.easyName].length > 1) {
      throw `Collision detected for [${collisionDetection[model.easyName]}]`;
    } else {
      throw `Collision detected for ${model['$class']} with easyName of ${model.easyName} ` +
        'but unable to find colliding classes';
    }
  }
  
  spec.definitions[model.easyName] = definition;
};

// Add models to the spec
builder.addModels = ({spec, modelMap, modelsInSpec, modelsToAdd, collisionDetection}) => {
  modelsInSpec = modelsInSpec || new Set();

  const newModels = new Set();
  Array.from(modelsToAdd).forEach((modelName) => {
    if (!modelsInSpec.has(modelName)) { 
      const model = modelMap[modelName];
      builder.addModel({spec, model, newModels, modelMap, collisionDetection});
      modelsInSpec.add(modelName);
    }
  });

  if (newModels.size > 0) {
    builder.addModels({spec, modelMap, modelsInSpec, modelsToAdd: newModels, collisionDetection});
  }
};

builder.addDocs = (spec, directory='') => {
  const operationFinder = util.buildOperationFinder(spec);

  // for each directory in the doc folder
  fs.readdirSync(directory)
    .filter(dir => fs.statSync(path.join(directory, dir)).isDirectory())
    .map(dir => path.join(directory, dir))
    .forEach(dir => {
      const dirName = path.basename(dir);
      const dirWithSlashes = '/' + dirName.replace(/-/g, '/');

      // get the methods
      const methodDirs = fs.readdirSync(dir);
      for (let methodDirName of methodDirs) {
        const methodDir = path.join(dir, methodDirName);
        const method = path.basename(methodDir).toLowerCase();

        // attempt to find the operation in the spec
        const operation = operationFinder({
          url: dirWithSlashes,
          method
        });

        if (operation) {
          const descriptionPath = path.join(methodDir, 'description.md');
          if (fs.existsSync(descriptionPath)) {
            operation.description = fs.readFileSync(descriptionPath, 'utf8');
          }

          const schemaPath = path.join(methodDir, 'schema.json');
          if (fs.existsSync(schemaPath)) {
            let schema;
            try {
              const schemaText = fs.readFileSync(schemaPath, 'utf8');
              schema = JSON.parse(schemaText);
            } catch (e) {
              console.log(`Unable to parse ${schemaPath} as JSON:`, e);
              continue;
            }

            // Copy the summary
            if (schema.summary) {
              operation.summary = schema.summary;
            }

            // Merge the parameters
            if (schema.parameters) {
              schema.parameters.forEach(parameter => {
                const op = operation.parameters.find(opParam => opParam.name === parameter.name);
                if (op) {
                  op.description = parameter.description;
                }
              });
            }
          }
        }
      }
    });
};
