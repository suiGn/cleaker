const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const stringify = require('json-stable-stringify');

const util = module.exports;

// This returns an OpenAPI compatible model schema
util.getModelSchema = (str, usedModels, modelMap) => {
  str = util.getClassName(str);

  if (util.isResponseEntityString(str)) {
    const nestedClass = util.parseResponseEntityString(str);
    return util.getModelSchema(nestedClass, usedModels, modelMap);
  }

  if (util.isListString(str)) {
    const nestedClass = util.parseListString(str);
    return {
      type: 'array',
      items: util.getModelSchema(nestedClass, usedModels, modelMap)
    };
  }

  if (util.isMapString(str)) {
    const {key, value} = util.parseMapString(str);
    if (util.toOpenAPIType(key) !== 'string') {
      console.log(`Unable to get schema for ${str}`);
      return;
    }
    return {
      type: 'object',
      additionalProperties: util.getModelSchema(value, usedModels, modelMap)
    };
  }

  const openapiType = util.toOpenAPIType(str);
  switch (openapiType) {
    case 'string':
      return {type: 'string'};
    case 'integer':
      return {type: 'integer', format: 'int32'};
    case 'boolean':
      return {type: 'boolean'};
    case 'object':
      // return an object if we can't get more specific
      if (str === 'java.lang.Object') {
        return {type: 'object'};
      }
      // unspecified maps are assumed to be maps to objects
      if (str === 'java.util.Map') {
        return {
          type: 'object',
          additionalProperties: {
            type: 'object'
          }
        };
      }

      const className = util.getClassName(str);
      if (modelMap[className]) {
        usedModels.add(className);
        return {'$ref': `#/definitions/${modelMap[className].easyName}`};
      }

      console.log(`Not able to find ${className} in modelMap`);
      return {type: 'object'};
  }
};

util.getClassName = str => {
  if (str.indexOf('class') === 0) {
    str = str.slice('class '.length);
  } else if (str.indexOf('interface') === 0) {
    str = str.slice('interface '.length);
  }

  if (str.indexOf('[L') === 0) {
    str = str.slice(2);
  }

  if (str[str.length - 1] === ';') {
    str = str.slice(0, -1);
  }

  str = str.replace(/Wrapper$/, '');
  
  return str;
};

// We can only use the last part of the class names for openapi
util.cleanClassName = str => {
  str = util.getClassName(str);
  return str.split('.').slice(-1)[0].replace(/\$/g, '');
};

util.toOpenAPIType = str => {
  str = util.getClassName(str);
  switch (str) {
    case 'java.lang.Void':
    case 'void':
      return;

    case 'java.lang.String':
      return 'string';

    case 'int':
      return 'integer';

    case 'java.lang.Boolean':
    case 'boolean':
      return 'boolean';

    default:
      return 'object';
  }
};

/*
 * Given a list of regexs, return a function that
 * determines if a given string is in that list
 */
util.buildListMatcher = regexList => {
  regexList = regexList || [];
  const list = regexList.map(str => new RegExp(`^${str}$`));
  return url => !!list.find((pattern) => {
    return pattern.test(url);
  });
};

util.buildRegexMap = regexHash => {
  const map = new Map();
  Object.keys(regexHash).map(regex => map.set(new RegExp(regex), regexHash[regex]));
  return map;
}

/*
 * Given an object where the keys are regexs, return
 * a function that returns a list of values for each
 * key that matches a string
 */
util.buildTagMatcher = tags => {
  tags = tags || {};
  const tagMap = util.buildRegexMap(tags);
  return url => {
    let urlTags = [];
    for (let [tagRegex, tagValue] of tagMap) {
      if (tagRegex.test(url)) {
        urlTags.push(tagValue);
      }
    }
    return urlTags;
  };
};

util.buildPathRewriter = pathRewriteMap => {
  pathRewriteMap = pathRewriteMap || {};
  const pathMap = util.buildRegexMap(pathRewriteMap);
  return (url, path) => {
    for (let [pathRegex, pathValue] of pathMap) {
      // See if this is a valid url
      if (pathRegex.test(url)) {
        // Get what we're replacing
        const ogPathParam = pathRegex.exec(url)[2];
        // Change its name in the parameters
        const param = path && path.parameters && path.parameters.find(p => p.name === ogPathParam);
        if (param) {
          param.name = pathValue;
        }

        // Replace the url with our desired value in the correct place
        url = url.replace(pathRegex, `$1${pathValue}$3`);
      }
    }
    return [url, path];
  };
};

util.buildPathFinder = spec => {
  const regexToPath = [];

  const orderedPaths = Object.entries(spec.paths)
  .sort(([pathNameA], [pathNameB]) => {
    if (pathNameA < pathNameB) return -1;
    if (pathNameA > pathNameB) return 1;
    return 0;
  });

  // Loop through each path
  for (let [pathName, path] of orderedPaths) {
    // Change the pathName to a regex
    const pathRegex = pathName.replace(/{.*?}/g, '[^/]*?') + '$';
    regexToPath.push({
      regex: new RegExp(pathRegex),
      path
    });
  }

  // Return a function that finds the match
  return url => {
    // Remove the query params from url
    const sanitizedUrl = url.split('?')[0];

    for (let regexPathPair of regexToPath) {
      if (regexPathPair.regex.test(sanitizedUrl)) {
        return regexPathPair.path;
      }
    }
  };
}

util.buildOperationFinder = spec => {
  const pathFinder = util.buildPathFinder(spec);
  return (req) => {
    const path = pathFinder(req.url);
    if (path && req.method) {
      return path[req.method.toLowerCase()];
    }
  };
}

util.ensureUniqueOperationIds = spec => {
  // go through each spec.paths[path][operation].operationId to find those that aren't unique
  const duplicates = new Set();
  const operationIdMap = {};
  for (let p in spec.paths) {
    const path = spec.paths[p];
    for (let op in path) {
      const operation = path[op];
      const opId = operation.operationId;
      if (operationIdMap[opId]) {
        duplicates.add(opId);
        operationIdMap[opId].push(operation);
      } else {
        operationIdMap[opId] = [operation];
      }
    }
  }

  duplicates.forEach(opId => {
    operationIdMap[opId].forEach(operation => {
      const splitOpId = opId.split(/(?=[A-Z])/);
      const tag = operation.tags[0];
      if (!opId.includes(tag)) {
        splitOpId.splice(1, 0, tag);
        operation.operationId = splitOpId.join('');
      }
    });
  });
};

// Ensures that models that cannot be updated via API only have readOnly properties
// Also ensure that 'id' properties are all readOnly
util.ensureReadOnlyProperties = spec => {
  // Get all models that can be passed to API
  const writeableModels = new Set();
  for (let [pathName, pathObject] of Object.entries(spec.paths)) {
    for (let [httpMethod, operation] of Object.entries(pathObject)) {
      for (let parameter of operation.parameters) {
        if (parameter.schema && parameter.schema['$ref']) {
          const modelName = _.last(parameter.schema['$ref'].split('/'));
          writeableModels.add(modelName);
        }
      }
    }
  }

  // Build definitionMap
  const definitionMap = {};
  for (let [definitionName, definition] of Object.entries(spec.definitions)) {
    definitionMap[definitionName] = definition;
  }

  // Add all models that are descendants of the models
  function addDescendants(definition) {
    /* istanbul ignore if */
    if (!definition.properties) return;

    for (let [propertyName, property] of Object.entries(definition.properties)) {
      if (property && property['$ref']) {
        const modelName = _.last(property['$ref'].split('/'));
        if (!writeableModels.has(modelName)) {
          // Add descendants of descendants
          addDescendants(definitionMap[modelName]);
          writeableModels.add(modelName);
        }
      }
    }
  }

  for (let writeableModel of writeableModels) {
    addDescendants(definitionMap[writeableModel]);
  }

  // Loop through each model
  for (let [definitionName, definition] of Object.entries(spec.definitions)) {
    // If a model is not in the writeable models
    if (!writeableModels.has(definitionName)) {
      // Set all the properties to readOnly
      for (let [propertyName, property] of Object.entries(definition.properties)) {
        /* istanbul ignore else */
        if (property) property.readOnly = true;
      }
    }

    // Ensure all id properties are readOnly
    if (definition.properties.id) {
      definition.properties.id.readOnly = true;
    }
  }
};

// This ensures consistent results when we diff
// json-stable-stringify is used, because a non-stringified version was unavailable
util.ensureConsistentStructure = spec => {
  spec.paths = JSON.parse(stringify(spec.paths));
  spec.definitions = JSON.parse(stringify(spec.definitions));
};

util.removeNils = obj => {
  if (_.isNil(obj)) return;

  if (_.isArray(obj)) {
    const newArr = [];
    for (let i = 0; i < obj.length; i++) {
      const res = util.removeNils(obj[i]);
      if (res) {
        newArr.push(res);
      }
    }
    return newArr;
  }

  if (_.isObject(obj)) {
    const newObj = {};
    for (let p of Object.keys(obj)) {
      newObj[p] = util.removeNils(obj[p]);
    }
    return newObj;
  }

  return obj;
}

util.prettyJSON = obj => JSON.stringify(obj, null, 2);

const mapRegex = /^java.util.Map<(.*?), (.*)>/;
util.isMapString = str => mapRegex.test(str);
util.parseMapString = str => {
  const regexResult = mapRegex.exec(str);
  return {
    key: regexResult[1],
    value: regexResult[2]
  };
};

const responseEntityRegex = /^org.springframework.http.ResponseEntity<(.*)>/;
util.isResponseEntityString = str => responseEntityRegex.test(str);
util.parseResponseEntityString = str => {
  return responseEntityRegex.exec(str)[1];
};

const listRegex = /^java.util.List<(.*)>/;
util.isListString = str => listRegex.test(str);
util.parseListString = str => {
  return listRegex.exec(str)[1];
};

util.overrideLinksAndEmbedded = (spec) => {
  const readOnlyObjectMap = {
    additionalProperties: {
      type: 'object'
    },
    readOnly: true,
    type: 'object'
  };

  for (let model of Object.values(spec.definitions)) {
    /* istanbul ignore else */
    if (model.properties) {
      if (model.properties._links) {
        model.properties._links = _.clone(readOnlyObjectMap);
      }

      if (model.properties._embedded) {
        model.properties._embedded = _.clone(readOnlyObjectMap);
      }
    }
  }

  // Remove the definitions that may have been associated with it
  /* istanbul ignore else */
  if (spec.definitions) {
    delete spec.definitions.Link;
    delete spec.definitions.LinksUnion;
    delete spec.definitions.EmbeddedObject;
  }
};

// Helper for adding whitespace (used from handlebars)
util.nbsp = (times) => {
  if (typeof times !== 'number') times = 1;
  return ' '.repeat(times);
};

// Helper for checking for property existence (used from handlebars)
util.exists = (obj, key) => {
  if (obj === null) return false;
  if (typeof obj === 'undefined') return false;

  return obj && obj.hasOwnProperty(key) && typeof obj[key] !== 'undefined';
};

util.getCommonType = (obj) => {
  if (!obj) return 'null';
  if (!obj.type) return 'object';
  if (obj.items) return 'array';
  if (obj.additionalProperties) return 'hash';

  switch (obj.type) {
    case 'integer':
      switch (obj.format) {
        case 'int32': return 'integer';
        case 'int64': return 'long';
        default: return 'integer';
      }
    case 'number':
      switch (obj.format) {
        case 'float': return 'float';
        case 'double': return 'double';
        default: return 'float';
      }
    case 'string':
      switch (obj.format) {
        case 'byte': return 'byte';
        case 'binary': return 'binary';
        case 'date': return 'date';
        case 'date-time': return 'dateTime';
        case 'password': return 'password';
        default: return 'string';
      }
    case 'boolean': return 'boolean';
    default: return 'object';
  }
};

util.handlebarsHelpers = {
    nbsp: (times) => util.nbsp(times),
    exists: (obj, key) => util.exists(obj, key),
    whitespace: () => '',
    eq: (v1, v2) => v1 === v2,
    ne: (v1, v2) =>  v1 !== v2,
    lt: (v1, v2) => v1 < v2,
    gt: (v1, v2) => v1 > v2,
    lte: (v1, v2) => v1 <= v2,
    gte: (v1, v2) => v1 >= v2,
    and: (v1, v2) => v1 && v2,
    or: (v1, v2) => v1 || v2,
    camelCase: str => _.camelCase(str),
    snakeCase: str => _.snakeCase(str),
    upperSnakeCase: str => _.snakeCase(str).toUpperCase(),
    capitalize: str => _.capitalize(str),
    upperCase: str => str.toUpperCase(),
    lowerCase: str => str.toLowerCase(),
    pascalCase: str => _.upperFirst(_.camelCase(str))
  };
